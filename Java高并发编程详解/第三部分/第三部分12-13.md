# 第三部分 深入理解volatile关键字
# 第十二章 volatile关键字的介绍
## 12.1 初识volatile关键字
多线程环境下操作共享资源，可能引起数据不一致等线程安全问题。(其实现在的JMM改善后已经尽量避免了这种情况)见代码，将volatile关键字修饰共享数据即可。  
**注意**：volatile只能修饰类变量和实例变量，对于方法参数，局部变量，实例常量，类常量都不能进行修饰。

## 12.2 机器硬件CPU
计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。
### 12.2.1 CPU Cache模型
![](https://i.postimg.cc/PJqBYszb/12-2.png)
在CPU和主内存之间的缓存数量已经增加到了3级，最靠近的叫L1(L1i,instruction和L1d,data)，然后是L2，L3和主内存。CPU Cache由很多个Cache Line构成，Cache Line可以说是最小缓存单位，目前主流大小是64字节。  
![](https://i.postimg.cc/bw03yV1q/12-3.png)
程序运行的时候，会将运算所需要的数据从主存复制一份到CPU Cache中，这样CPU可以直接对Cache进行数据读写，当结束后再把最新数据刷写到主内存中。

### 12.2.2 CPU缓存一致性问题
由此可能引入缓存不一致的问题。
比如i++，具体操作如下：
1. 读取主内存的i到CPU Cache中
2. 对i进行加一操作
3. 将结果写回到CPU Cache中
4. 将数据刷新到主内存中

在多线程情况下，每个线程有自己的工作内存(本地内存，对应CPU的Cache)，变量i会在多个线程的本地内存中都存在一个副本。如果两个线程同时i++,同时存入缓存，同时写入主内存，那么很可能两次自增后结果还是1，这就是典型的缓存不一致。  
缓存性一致性协议中最为出名的是Intel的MESI协议，当CPU在操作Cache数据时，如果发现是共享变量(也就是其他CPU Cache中存在副本)，那么进行如下操作:
1. 读取操作，不做任何处理，只是将Cache中的数据读取到寄存器
2. 写入操作，发出信号通知其他CPU将该变量的Cache line置为无效状态，其他CPU在读取时不得不到主内存中再次获取

当一个变量被volatile修饰时，其实就具备一下两层含义：
1. 当某个线程对该变量进行修改后，会立即将修改后的新值刷回主存，保证主存中永远都是最新的数据
2. 对该比变量施加了缓存行一致协议。也就是说，当前线程对该变量进行修改后，系统会通知其他线程它们工作缓存中数据已经无效，那么其他线程要再次读取该变量时，就会重新从主存中读取该变量，然后复制一份在它的工作缓存中。

## 12.3 Java内存模型
![](https://i.postimg.cc/vZDy3R7T/12-5.png)  
Java的内存模型(Java Memory Mode, JMM)定义了线程和主内存之间的抽象关系：
- 共享变量存储于主内存之中，每个线程都可以访问
- 每个线程都有私有的工作内存(本地内存)
- 工作内存只存储该线程对共享变量的副本
- 线程不能直接操作主内存，只有先操作了工作内存之后才能写入主内存
- 工作内存和Java内存模型一样也是一个抽象的概念，他其实并不存在，涵盖了缓存，寄存器，编译器优化及硬件等。

所以变量失效的原理和上面说的类似。  
Java的内存模型是一个抽象的概念，与硬件的结构不完全一样。
![](https://i.postimg.cc/4yKvWx3w/12-6.png)
计算机物理内存不会存在栈内存和堆内存的划分，无论是堆内存还是虚拟机栈内存都会对应到物理的主内存，当然也有一部分堆栈内存的数据会存入CPU Cache寄存器中。

JVM和JMM的联系：  
JMM中的主内存、工作内存与JVM中的Java堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。

## 12.4 本章总结
如上。

# 第十三章 深入volatile关键字
## 13.1 并发编程的三个重要特性
原子性、有序性、可见性
### 13.1.1 原子性
原子性是指一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉。(举例A给B转账100，A账户-100，B账户+100，要么都成功，要么都失败，不能出现A少100B不变等情况)。
当然，java内存模型中定义了8种操作都是原子的，不可再分的。

- lock(锁定)：作用于主内存中的变量，它把一个变量标识为一个线程独占的状态；
- unlock(解锁):作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
- read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便后面的load动作使用；
- load（载入）：作用于工作内存中的变量，它把read操作从主内存中得到的变量值放入工作内存中的变量副本
- use（使用）：作用于工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作；
- assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作；
- store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送给主内存中以便随后的write操作使用；
- write（操作）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。

那么如何理解这些指令了?比如，把一个变量从主内存中复制到工作内存中就需要执行read,load操作，将工作内存同步到主内存中就需要执行store,write操作。注意的是：**java内存模型只是要求上述两个操作是顺序执行的并不是连续执行的**。也就是说read和load之间可以插入其他指令，store和writer可以插入其他指令。比如对主内存中的a,b进行访问就可以出现这样的操作顺序：read a,read b, load b,load a。

由原子性变量操作read,load,use,assign,store,write，可以**大致认为基本数据类型的访问读写具备原子性**（例外就是long和double的非原子性协定）

如果我们需要更大范围的原子性操作就可以使用lock和unlock原子操作。尽管jvm没有把lock和unlock开放给我们使用，但jvm以更高层次的指令monitorenter和monitorexit指令开放给我们使用，反应到java代码中就是---synchronized关键字，也就是说**synchronized满足原子性**。

**注意**：volatile关键字不保证原子性；两个原子性操作结合也不一定是原子性(i++)；

	for (int i = 0; i < 10; i++) {
            Thread thread = new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i < 10000; i++)
                        counter++;
                }
            });
            thread.start();
        }
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(counter);
期望结果是10*10000 = 100000，但结果比其小。原因？上面说个原子性的8种操作，简单的读取和赋值是原子性的，但是i++并不是。可之前不是说volatile会让缓存失效嘛？为什么这里又不行了呢？？？  
**答：**线程1读取counter值时被阻塞，线程2操作写入，此时确实会通知其他线程缓存counter失效，下次读取时会到主存取数据。但线程1阻塞恢复后并没有再次读取counter的值！！还是原本的，所以不能保证原子性。  
如果让volatile保证原子性，必须符合以下两条规则：

1. **运算结果并不依赖于变量的当前值，或者能够确保只有一个线程修改变量的值；**
2. **变量不需要与其他的状态变量共同参与不变约束**

### 13.1.2 可见性
可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改。  
Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是volatile的特殊规则保证了新值能**立即同步到主内存**，以及每次使用前立即从主内存刷新。因此我们可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。  
通过之前对synchronzed内存语义进行了分析，当线程获取锁时会从主内存中获取共享变量的最新值，释放锁的时候会将共享变量同步到主内存中。从而，**synchronized具有可见性**。同样的在volatile分析中，会通过在指令中添加lock指令，以实现内存可见性。因此,**volatile具有可见性**。

### 13.1.3 有序性
处理器为了提高程序的运行效率，可能会进行**指令重排序**(Instruction Recorder),当然他会严格遵守指令间的数据依赖关系，不会进行任意重排序。  
单线程情况下，无论怎样重排序都可以保证结果一致，但多线程不一定：    

    private boolean initialized = false;
    private Context context;
    public Context load(){
    	if(!initialized){
    		context = loadContext();
    		initialized = true;
    	}
    	return context;
    }
如果多线程情况下，线程1的initialized = true安排在了context = loadContext()之前，那如果此时线程2满足条件会直接返回一个还未加载成功的context。

## 13.2 JVM如何保证三大特性
JVM采用内存模型的机制来屏蔽各个平台和操作系统之间的内存访问的差异。
### 13.2.1 JMM与原子性
总结：**volatile不保证原子性**
![](https://i.postimg.cc/2SV6396p/yzx1.png)
![](https://i.postimg.cc/X72qj6nc/yzx2.png)

1. 多个原子性性的操作在一起就不再是原子性操作了
2. 简单的读取与赋值操作都是原子性的，将一个变量赋给另外一个变量的操作不是原子性的。
3. **Java内存模型（JMM）只保证了基本读取和赋值的原子性操作，其他的均不保证**，如果想要使得某些代码片段具备原子性，需要使用关键字synchronized，或者JUC中的lock。如果想要使得int等类型自增操作具备原子性，可以使用JUC包下的原子封装类型java.util.concurrent.atomic.*

### 13.2.2 JMM与可见性
总结：**volatile保证可见性**
在多线程的环境下，如果某个线程首次读取共享变量，则首先到主内存中获取该变量，然后存入工作内存中，以后只需要在工作内存中读取该变量即可。同样如果对该变量执行了修改的操作，则先将新值写入工作内存中，然后再刷新至主内存中。但是什么时候刷新至主内存中是不大确定的。  
Java提供了下面三种方式保证可见性：
- 使用关键字volatile：对于共享资源的读操作会直接在主内存中进行，缓存到工作内存。写操作先修改工作内存，结束后立刻刷新到主内存，使其他工作内存的共享资源失效。
- 使用关键字synchronized：保证同一时刻只有一个线程获得锁，然后同步，锁释放之前会刷新到主内存中。
- JUC提供的显式锁Lock：同synchronized

### 13.2.3 JMM与有序性
总结：**volatile保证有序性**
Java提供三种保证有序性的方法：
- 使用关键字volatile
- 使用关键字synchronized
- 使用显式锁Lock

此外，Java的内存模型中具备一些天生的有序性规则，不需要任何同步手段就能保证有序性，这个规则成为happens-before原则。如果两个操作的次序无法从happens-before推导，就无法保证有序性。 

happens-before原则定义如下：

1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 

2. 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。

下面是happens-before原则规则：  

1. 程序次序规则：在一个线程内，代码按照编写时的次序执行，编写在后面的操作发生于编写在前面的操作之后。

这句话看起来是程序按照编写的顺序来执行，但是虚拟机还是可能对程序代码的指令重排序，只要保证一个线程内最终的结果和代码顺序执行的结果一致即可。

2. 锁定原则：一个unlock操作要先行发生于对同一个锁的lock操作。

无论是单线程还是多线程的环境下，如果同一个锁是锁定状态，那必须先对其执行释放操作之后才能继续执行lock操作。

3. volatile变量规则：对一个变量的写操作要早于对这个变量的读操作。

如果一个变量使用volatile关键词修饰，一个线程怼他进行读操作，一个线程对他进行写操作，那么写操作肯定要先行发生于读操作。

4. 传递规则：如果操作A先于操作B，而操作B又先于操作C，则可以得出操作A肯定先于操作C。

5. 线程启动原则：Thread对象的start（）方法先行发生于对该线程的任何动作，只有start之后线程才能真正运行，否则Thread也只是一个对象而已。

6. 线程中断规则：对线程执行interrupt（）方法肯定要优先于捕获到中断信号。如果线程收到了中断信号，那么在此之前势必要有interrupt（）。

7. 线程终结原则：线程中所有的操作都要先行发生于线程的终止检测，通俗的讲，线程的任务执行、逻辑单元执行肯定要发生于线程死亡之前。

8. 对象的终结规则：一个对象的初始化完成先行于finalize（）方法之前。

## 13.3 volatile关键字深入解析
### 13.3.1 volatile关键字的语义
被volatile关键字修饰的变量具有以下两个语义：
- 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
- 禁止进行指令重排序。

可见性的保证:让其他线程工作内存中的变量失效(CPU CacheLine失效)，重新从主存中读取。  
顺序性的保证:直接禁止JVM对volatile修饰的指令重排序，但前后的指令则不受影响，可能被重排序。  
不能保证原子性：线程可能被阻塞，阻塞后不会读取新的值，导致数据不一致。

### 13.3.2 volatile的原理和实现机制
通过OpenJdk的unsafe.cpp源码，会发现被volatile修饰的变量存在一个lock;的前缀：
![](https://i.postimg.cc/pL8w0Kch/lock.png)  
"lock;"前缀相当于一个内存屏障，提供如下保障:
- 确保重排序不会将后面代码排到内存屏障之前
- 确保重排序不会将前面代码排到内存屏障之后
- 确保执行到内存屏障修饰的指令时前面代码全部执行完成
- 强制将线程工作内存中值的修改刷新至主内存
- 如果是写操作，则会导致其他线程工作内存(CPU Cache)缓存数据失效

### 13.3.3 volatile的使用场景
因为不具备原子性，我们充分利用可见性和顺序性。  
(1)开关控制利用可见性的特点 —— 线程关闭  

	public class ThreadCloseable extends Thread {

		//可见性 关闭线程
		private volatile boolean started = true;
		
		@Override
		public void run(){
			while(started){
				//do something
			}
		};
		
		public void shutdown(){
			this.started = false;
		}
	}
(2)状态标记利用顺序性特点 —— 改变状态变量  
上文的context例子中，可以保证加载完毕后再将状态变量置为true  
(3)单例模式double-check利用其顺序性  
见下一张

### 13.3.4 volatile和synchronized
(1)使用的区别
- volatile修饰实例变量或者类变量，不能修饰方法以及方法参数和局部变量、常量等
- synchronized不能修饰变量，只能是方法或语句块
- volatile可以修饰null，但synchronized同步的monitor不能使null

(2)原子性的保证
- volatile不行，synchronized可以
- 除了long和double其他的基本类型读写操作都是原子性的；引用类型的读写操作也是原子性的。long和double变量被volatile关键字修饰之后，读写(赋值操作，读取操作)都是原子操作

(3)可见性的保证
- 均可以实现，但机制完全不同
- synchronized通过JVM指令monitor enter 和monitor exit实现代码串行化，monitor exit时所有共享资源刷新到主内存中
- volatile偏硬件，使用“lock;”关键字使其他线程工作内存数据失效

(4)有序性的保证
- volatile禁止JVM编译器以及处理器对其进行重排序，能保证
- synchronize排他用串行化执行，内部也可能发生重排序，但是最终结果保持一致(相当于单线程)

(5)其他
- volatile不会使线程进入阻塞，但synchronized会

## 13.4 本章总结 
如上

